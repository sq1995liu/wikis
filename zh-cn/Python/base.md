## 内存管理

> **python有一个私有堆空间来保存所有的对象和数据结构，我们无法访问它，是解释器在管理。**


## 对象存储

首先，在python中，万物皆对象，每个对象第一次被创建时都会在内存中开辟一块空间来存储。    

## 引用计数

每创建一个对象，对应的引用为1。如果这个对象被赋值或引用时，对应的引用计数+1，如果被销毁，引用计数-1。若该对象的引用计数为0时，对象会自动销毁。


## 循环引用
```python
a_list = []
b_list = []
a_list.append(b_list)
b_list.append(a_list)
```
a_list与b_list相互引用，如果不存在其他对象对他们的引用。a_list与b_list的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。

## 标记-清除

标记清除机制其实就是为了解决循环引用问题的，首先遍历所有对象，如果对象除了循环引用外还有别的引用，说明其有效，就标记为可达，如果不可达，则对其进行清除

## 分代回收

这种机制是典型的以空间换时间的技术。当对象被创建时标记为第0代，经过一次垃圾回收之后，余下的对象被标记为第1代，最高为第2代。0代触发将清理所有三代，1代触发会清理1,2代，2代触发后只会清理自己。

这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。

## 对象缓存

类型值的内置数据类型，数字、字符串、列表、字典等都会有自己的对象缓存池，这样做的好处是，避免了频繁的申请内存，释放内存，这样会极大的降低应用程序的运行速度，还会造成大量的碎片。因此提供对象缓存机制是非常必要的。

## 多次赋值

对于整数和短小的字符，python会进行缓存，不会创建多个相同对象

此时，被多次赋值，只会有多份引用

## 内存地址

可以通过id()来查看

a is b 判断 a 对象是否就是 b 对象（通过id来判断）

a == b 判断 a 对象的值是否和 b 对象的值相等（通过value来判断）

## 内存占用

```python
sys.getsizeof(a)
```
## 查看引用计数

```python
sys.getrefcount(a)
```




