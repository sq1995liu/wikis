### 多任务概念、目的

概念：同一时间内，执行多个任务

目的：充分利用CPU资源，提高程序的执行效率

> 例子：一边在用浏览器上网，一边在听网易云，一边再用typora写博客，这就是多任务，至少同时有3个任务正在运行。

### 进程

进程是CPU资源分配的最小单位，是正在运行的程序的实例

**特点**

独立性：每个进程都有都有独立的代码和数据空间（程序上下文），因此它们之间的资源分配和调度也相互独立（也就是常说的进程间彼此独立）。

动态性：程序只是一个静态的指令集合，而进程是程序运行的动态实例。

并发性：同时运行多个进程，能够最大化利用多核CPU的资源，提升运行速度。

### 线程

线程是cpu调度的最小单位。它被包含在进程之中，是进程中的实际运作单位

### 注意点

线程是进程的组成部分，一个线程必须有一个父进程，一个进程可以拥有多个线程

多线程之间共享资源，同时也会产生资源竞争问题

线程的执行是无序的，是 CPU 进行调度的

### 多线程

同时执行多个不同程序

> 例子：一家超市中同时有多个收银台在工作

### join阻塞

主线程等待子线程执行完毕才退出（超市关门需要等顾客离开）

### 守护线程

主线程退出时，需要子线程随主线程一起退出（超市关门不等顾客离开）

### 解决资源竞争

线程同步：先执行哪个线程，再执行哪个线程，使用 join() 方法实现。（同步就是按照你事先定义好的顺序）

互斥锁：python 提供的一种机制，同一时刻只有一个线程，能够获得这把锁

### 死锁

在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。

### 线程池和进程池的意义

池的概念在于，预先创建好一定数量的线程

可以不需要重复创建，避免频繁的**生产**和**释放**线程资源导致的系统**浪费资源**

白话：线程池就是管理线程的池子，当有任务要处理时，不用频繁创建新线程，而是从池子里拿个线程出来处理。当任务执行完，线程并不会被销毁，而是再等待下一个任务。因此可以节省资源，提高响应速度。

### 数据库连接池

python编程中可以使用pymysql进行数据库连接及增删改查操作，但每次连接mysql请求时，都是独立的去请求访问，比较浪费资源，而且访问数量达到一定数量时，对mysql的性能会产生较大的影响。因此实际使用中，通常会使用数据库的连接池技术，来访问数据库达到资源复用。

与线程池，进程池概念平移。都是为了达到资源服用

连接池对性能的提升：

- 在程序创建连接的时候，可以从一个空闲的连接中获取，不需要重新初始化连接，提升获取连接的速度。
- 关闭连接的时候，把连接放回连接池，而不是真正的关闭，所以可以减少频繁的打开和关闭连接。

### 僵尸、孤儿进程

僵尸进程：当父进程开子进程后，子进程工作已经结束，但是父进程迟迟不去回收，这就会导致子进程陷入**僵尸进程**状态

危害：僵尸进程会一直占用PID等进程资源，无法释放进程控制块，导致新的进程无法使用。

孤儿进程：当父进程开启后，先于子进程退出，那么此时子线程没人回收，就造成了孤儿进程。

在linux操作系统下，有专门进行善后的孤儿院部门，也就是我们常说的init这个进程

### 并发、并行

>举个例子：假设你开了一个餐馆，只有一个厨师，但同时有两桌客人点了菜。简称A桌和B桌，为了让两桌客人都满意，你可以安排厨师，交叉地为两桌客人做菜。为A桌做一道菜，再为B桌做一道菜，如此交叉进行，直到做完所有的菜。这个只能叫并发，不能叫并行。如果你多雇一个厨师，两个厨师，一个做A桌的菜，一个做B桌的菜，这个就算并行了。

并发：一个时间段内，程序交替的去执行

并行：在多核 CPU 中，多个任务，在不同的 CPU 上，同时执行。

### cpu密集型/IO密集型

cpu密集型也叫计算密集型，它的特点就是要进行大量的计算，消耗CPU资源，这个时候使用多进程

IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，使用多线程更为合适

### 协程

协程，又称微线程，纤程，协程是一种用户态的轻量级线程，用户态：具备自主意识，完全由用户控制。

线程在切换时会保存到CPU的栈里，协程拥有自己的上下文寄存器和栈

优缺点：

优：可以在io任务时进行切换，避免io阻塞造成资源浪费

缺：无法利用多核资源，因为协程的本质是单线程

说白了就是，当协程遇到io操作而阻塞时，立即切换到别的任务，如果操作完成则进行回调返回执行结果，提高了效率，同时这样也可以充分利用 CPU 和其他资源，这就是异步协程的优势，并且协程本质上是个单进程，相对于多进程来说，无需进程间上下文切换的开销，无需原子操作锁定及同步的开销，编程模型也非常简单。

>举例子：在超市买苹果，用户需要10个apple，可是货架上只有5个，如果是同步思想的话，拿完5个apple，用户就会等待苹果上架（相当于程序阻塞），利用异步思想，货架空了，顾客可以选择去找店员补货（也就是切换出来执行别的操作）

### greenlet

使用greenlet模块可以实现协程，这是一个由C扩展而来的用来实现协程的模块，但是需要通过switch来手动切换不同的代码块来运行协程

### gevent

gevent可以使用gevent.spawn来创建一个协程，免去了手动切换协程的过程

使用gevent中的monkey补丁可以在协程遇到io操作堵塞时自动切换到其他协程

### 迭代器生成器

迭代的概念：上一次输出的结果为下一次输入的初始值，重复的过程称为迭代,每次重复即一次迭代，并且每次迭代的结果是下一次迭代的初始值

### 迭代器

对于没有索引的数据类型，必须提供一种不依赖索引的迭代方式。

迭代器是访问集合内元素的一种方式，仅是一个容器对象，它有两个基本方法：next（返回容器的下一个元素），**iter**（返回迭代器本身）

### 生成器

生成器会生成一系列的值用于迭代，这样看它又是一种可迭代对象。它是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。

生成器内部实现了迭代器协议，并且支持延迟操作，所谓的延迟操作，就是在我需要的时候才会产生结果，而不是立即产生结果。

> 举个例子，用列表推导式创建一个有100万元素的列表，它会占用很大的内存，如果我们只需要访问前几个元素的话，那后面的元素更是浪费了，这个时候生成器就可以帮我们很好的解决问题，哪怕是100万个元素，它调用一次也只会返回一个结果，这就是延迟操作。

生成器实现方式：

- 生成器函数：定义形式跟普通函数一样，只是常规的函数中的return会立刻返回结果退出函数，而yield语句可以返回多次值，每次返回都会将函数暂停，下一次next会从上一次暂停的位置继续执行

- 生成器推导式：类似于列表推导，但是，生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表





